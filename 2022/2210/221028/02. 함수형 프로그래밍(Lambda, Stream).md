# 02. 함수형 프로그래밍(Lambda, Stream)

## 1. Lambda

- 일반적인 계산기 코드

```java
interface Calculator{
    int sum(int a, int b);
}

class MyCalculator implements Calculator{
    public int sum(int a, int b){
        return a+b;
    }
}

public class LambdaPractice {
    public static void main(String[] args){
        MyCalculator mc = new MyCalculator();
        int result = mc.sum(3,4);
        System.out.println(result); // 7출력
    }
}
```

- Lambda 활용

```java
interface Calculator{
    int sum(int a, int b);
}

public class LambdaPractice {
    public static void main(String[] args){
        Calculator mc = (int a, int b) -> a+b;
        int result = mc.sum(3,4);
        System.out.println(result);
    }
}
```

`(int a, int b) -> a+b`

- -> 뒤의 a+b가 리턴값에 해당한다.



#### **인터페이스 사용시 주의 사항**

- Calculator 인터페이스의 메서드가 1개 이상이면 람다함수를 사용할 수 없다.

- 람다 함수를 사용할 때 인터페이스에 `@FunctionalInterface` 어노테이션을 추가해야한다.

- `@FunctionalInterface`: 2개 이상의 메서드를 가진 인터페이스를 작성하는 것을 불가능하게 만듬

- `(int a, int b) -> a+b`를 축약하면 `(a, b) -> a+b`가 가능하다.
  - `int`는 인터페이스에 이미 정의되었으므로 가능하다.



> Integer.sum

- `(a,b) -> a+b `는 `Integer.sum(int a, int b)`와 동일하다.
- `Integer::sum`으로 축약이 가능하다
  - `::`는 클래스와 메서드를 구분하여 표기한다.



> BiFunction 인터페이스

`BiFunction<Integer, Integer, Integer> mc = (a,b) -> a+b;`

`import java.util.function.BiFunction;`

`<입력항목, 입력항목, 출력항목>`

- BiFunction은 입출력 항목의 타입을 다양하게 사용할 수 있다.

- 모두 동일한 타입을 가질 경우 `BinaryOperator<Integer>`를 사용
  - `import java.util.function.BinaryOperator`



## 2. 스트림 (Stream)

`int[] data = {5,6,4,2,3,1,1,2,2,4,8}` 정수 배열이 있다.

이 배열에서 짝수만 찾아 중복을 제거한 후에 역순으로 정렬하는 프로그램을 작성하라

```java
import java.sql.Array;
import java.util.*;
public class StreamPractice {
    public static void main(String[] args){
        int[] data = {5, 6, 4, 2, 3, 1, 1, 2, 2, 4, 8};

        // 짝수만 포함하는 ArrayList 생성
        ArrayList<Integer> dataList = new ArrayList<>();
        for (int i=0; i<data.length; i++){
            if(data[i] % 2 == 0){
                dataList.add(data[i]);
            }
        }

        // Set을 사용하여 중복을 제거
        HashSet<Integer> dataSet = new HashSet<>(dataList);

        // Set을 다시 List로 변경
        ArrayList<Integer> distinctList = new ArrayList<>(dataSet);

        // 역순으로 정렬
        distinctList.sort(Comparator.reverseOrder());

        // Integer 리스트를 정수 배열로 변환
        int[] result = new int[distinctList.size()];
        for (int i=0; i< distinctList.size(); i++){
            result[i] = distinctList.get(i);
        }
    }
}
```

- Stream을 사용하면

```java
import java.util.*;
public class StreamPractice {
    public static void main(String[] args) {
        int[] data = {5, 6, 4, 2, 3, 1, 1, 2, 2, 4, 8};
        int[] result = Arrays.stream(data) // IntStream을 생성
                .boxed()					// IntStream을 Stream<Integer>로 변경
                .filter((a) -> a % 2 == 0)  // 짝수만 걸러내기
            	.distinct() 				// 중복 제거
                .sorted(Comparator.reverseOrder()) // 역순 정렬
                .mapToInt(Integer::intValue) // Stream<Integer>를 IntStream으로 변경
                .toArray();					// int[] 배열로 반환
    }
}
```

1. `Arrays.stream(data)`으로 정수 배열을 IntStream으로 생성한다.
2. `.boxed()` 로 IntStream을 Integer의 Stream으로 변경한다. 이렇게 하는 이유는 뒤에서 사용할 `Comparator.reverseOrder` 와 같은 메서드는 원시타입인 int 대신 Integer를 사용해야 하기 때문이다.
3. `.filter((a) -> a % 2 == 0)`로 짝수만 필터링한다. 이 때 사용한 `(a) -> a % 2 == 0` 구문은 위에서 공부한 람다 함수이다. 입력 a가 짝수인지를 조사하는 람다함수로 짝수에 해당되는 데이터만 필터링한다.
4. `.distinct()`로 스트림에서 중복을 제거한다.
5. `.sorted(Comparator.reverseOrder())`로 역순 정렬한다.
6. `.mapToInt(Integer::intValue)`로 Integer의 Stream을 IntStream으로 변경한다. 왜냐하면 최종적으로 `int[]` 타입의 배열을 리턴해야 하기 때문이다.
7. `.toArray()`를 호출하여 IntStream의 배열인 `int[]` 배열을 리턴한다.