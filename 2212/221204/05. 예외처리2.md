# 05. 예외처리2

> throws 키워드를 통한 처리 위임

- method에서 처리해야 할 하나 이상의 예외를 호출한 곳으로 전달(처리 위임)
- 예외가 없어지는 것이 아니라 단순히 전달됨
- 예외를 전달받은 메서드는 다시 예외 처리의 책임 발생

```java
void exceptionMethod() throws Exception1, Exception2...{
    //예외 발생 코드
}

void methodCaller() {
    try{
        exceptionMethod();
    }catch(Exception e){}
}
```

- 처리하려는 예외는 조상 타입으로 throws 처리 가능



> 로그 분석과 예외의 추적

- Throwable의 printStackTrace는 메서드 호출 스택 정보 조회 가능
  - 최초 호출 메서드에서부터 예외 발생 메서드 까지의 스택 정보 출력
- 꼭 확인해야할 정보
  - 어떤 예외인가? : 예외의 종류
  - 예외 객체의 메시지는 무엇인가? : 예외의 원인
  - 어디서 발생했는가? : 디버깅 출발점
    - 직접 작성한 코드를 디버깅 대상으로 삼을 것
    - 참조하는 라이브러리는 과감히 건너 뛰기



> 사용자 정의 예외

- API에 정의된 exception이외에 필요에 따라 사용자 정의 예외 클래스 작성

- 대부분 Exception 또는 RuntimeException 클래스를 상속받아 작성

  - checked exception 활용: 명시적 예외 처리 또는 throws 필요

    (코드는 복잡해지지만 처리, 누락 등 오류 발생 가능성은 down)

  - runtime exception 활용: 묵시적 예외 처리 가능

    (코드는 간결해지지만 예외 처리, 누락 가능성 발생)

- 사용자 정의 예외를 만들어 처리하는 장점

  - 객체의 활용: 필요한 추가정보, 기능 활용 가능
  - 코드의 재사용: 동일한 상황에서 예외 객체 재사용 가능
  - throws 메커니즘의 이용: 중간 호출 단계에서 return 불필요





