# 5-6. 생성자

---

## 생성자(Constructor)

```java
(... 생략 ...)

public class Sample{
    public static void main(String[] args) {
        HouseDog dog = new HouseDog();
        System.out.println(dog.name);
    }
}

// output
// null
```

- dog 객체의 name 변수에 아무런 값도 설정하지 않았기 때문에 null이 출력될 것이다.
- 그렇다면 name 이라는 객체변수에 값을 무조건 설정해야만 객체가 생성될 수 있도록 강제하는 방법? → 생성자를 이용

```java
(... 생략 ...)

class HouseDog extends Dog {
    // 추가된 메서드(클래스명과 동일한 이름)
    HouseDog(String name) {
        this.setName(name);
    }

    void sleep() {
        System.out.println(this.name + " zzz in house");
    }

    void sleep(int hour) {
        System.out.println(this.name + " zzz in house for " + hour + " hours");
    }
}

(... 생략 ...)
```

- 생성자 규칙
  1. 클래스명과 메서드명이 동일
  2. 리턴타입을 정의하지 않음(void도 사용하지 않음)

```java
new 클래스명(입력인수, ...)

HouseDog dog = new HouseDog("happy");  // 정상 작동

HouseDog dog = new HouseDog();  // 컴파일 오류
```

 

## 디폴트(default) 생성자

```java
// 1번 코드
class Dog extends Animal {
    void sleep() {
        System.out.println(this.name + " zzz");
    }
}
```

```java
// 2번 코드
class Dog extends Animal {
    Dog() {
    }

    void sleep() {
        System.out.println(this.name + " zzz");
    }
}
```

- 2번 코드에는 생성자가 구현되어 있음
- 2번 코드의 생성자처럼 입력항목이 없고, 생성자 내부에 아무 내용이 없는 생성자를 디폴트 생성자라고 함
- 만약 1번 코드처럼 생성자가 하나도 없는 클래스라면 컴파일러는 자동으로 2번코드와 같은 디폴트 생성자를 추가함.
  - 하나라도 구현되어 있다면 컴파일러는 디폴트 생성자를 추가하지 않음



## 생성자 오버로딩

```java
class HouseDog extends Dog {
    // 1번 생성자
    HouseDog(String name) {
        this.setName(name);
    }
    // 2번 생성자
    HouseDog(int type) {
        if (type == 1) {
            this.setName("yorkshire");
        } else if (type == 2) {
            this.setName("bulldog");
        }
    }
```

- `new HouseDog("happy")` 사용 가능
- `new HouseDog(1)` 사용 가능
