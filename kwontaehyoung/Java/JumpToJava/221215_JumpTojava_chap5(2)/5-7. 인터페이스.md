# 5-7. 인터페이스

---

## 인터페이스는 왜 필요한가?

- 같은 부모 클래스를 갖는 각각의 자식 클래스마다 부모 클래스의 메서드가 각각의 자식 클래스의 자료형으로 입력을 받아야하는 경우
- 자식 클래스가 추가될 때마다 메서드 오버로딩이 필요 → 번거로움



## 인터페이스 작성하기

```java
interface Predator {
}

class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

(...생략...)
```

- 위 코드와 같이 인터페이스는 class가 아닌 interface 라는 키워드를 이용하여 작성
  - 인터페이스는 클래스와 마찬가지로 Predator.java와 같은 단독 파일로 저장하는 것이 일반적
  
  

```java
class Tiger extends Animal implements Predator {
}

class Lion extends Animal implements Predator {
}

(...생략...)
```

- 인터페이스 구현은 위와 같이 implements 라는 키워드를 사용한다.
- 이렇게 Tiger, Lion 클래스가 Predator 인터페이스를 구현하게 되면 Zookeeper 클래스의 feed 메서드를 다음과 같이 변경 할 수 있다.



```java
(...생략...)

class Zookeeper {
    void feed(Predator predator) {
        System.out.println("feed apple");
    }
}

(...생략...)
```

- feed 메서드의 입력으로 Tiger, Lion을 각각 필요로 했지만 이제 이것을 Predator라는 인터페이스로 대체할 수 있게 되었다.
  - tiger - Tiger 클래스의 객체, Predator 인터페이스의 객체
  - lion - Lion 클래스의 객체, Predator 인터페이스의 객체



## 인터페이스의 메서드

```java
(... 생략 ...)

class ZooKeeper {
    public void feed(Predator predator) {
        System.out.println("feed apple");  // 항상 feed apple 만을 출력한다.
    }
}

(... 생략 ...)
```

- feed 메서드는 어떤 동물을 입력인자로 넣든 `feed apple` 만 출력함.
- 입력인자에 따라 다르게 출력하고 싶다면

```java
interface Predator {
    String getFood();  // 추가 코드
}

(...생략...)
```

- 인터페이스의 메서드는 이름과 입출력에 대한 정의만 있고 그 내용은 없다. → 인터페이스의 규칙이기 때문
- 이제 Tiger, Lion 클래스에 getFood 메서드를 구현해야함

```java
(... 생략 ...)

class Tiger extends Animal implements Predator {
    // 인터페이스의 메서드는 항상 public으로 구현해야 함.
    public String getFood() {
        return "apple";
    }
}

(... 생략 ...)
```

- 이제 ZooKeeper 클래스도 다음과 같이 변경

```java
(... 생략 ...)

class ZooKeeper {
    void feed(Predator predator) {
        System.out.println("feed "+predator.getFood());
    }
}

(... 생략 ...)
```

- feed 메서드가 `feed apple` 을 출력하던 것에서 `"feed "+predator.getFood()` 를 출력하도록 변경



## 인터페이스의 핵심과 개념

- ZooKeeper 클래스를 Predator 인터페이스를 이용하여 구현했더니 단 한개의 feed 메서드로 구현이 가능해짐
  
  - ZooKeeper 클래스가 동물들의 종류에 의존적인 클래스에서 독립적인 클래스가 되었다는 점이 인터페이스의 핵심

- 인터페이스 개념 예시
  
  - USB 포트 → 물리적 세계의 인터페이스
  
  | 물리적 세계            | 자바 세계                     |
  | ----------------- | ------------------------- |
  | 컴퓨터               | ZooKeeper                 |
  | USB 포트            | Predator                  |
  | 하드디스크, 디지털 카메라, … | Tiger, Lion, Crocodile, … |

 

### 상속과 인터페이스

- 다음의 작업을 수행하면 Predator 인터페이스와 동일한 효과를 거둘 수 있다.
  1. Animal 클래스에 getFood 메서드를 추가함
  2. Tiger, Lion 등에서 getFood 메서드를 오버라이딩함
  3. Zookeeper의 feed 메서드가 Predator 대신 Animal을 입력 자료형으로 사용
- 하지만 상속은 자식 클래스가 부모 클래스의 메서드를 오버라이딩하지 않고 사용할 수 있음
- 따라서, 해당 메서드를 반드시 구현해야 한다는 “강제성”을 갖지 못함
- 인터페이스는 인터페이스의 메서드를 반드시 구현해야 하는 “강제성”을 갖는다는 점을 기억!



## 디폴트 메서드

```java
interface Predator {
    String getFood();

    default void printFood() {
        System.out.printf("my food is %s\\n", getFood());
    }
}
```

- 디폴트 메서드는 메서드명 가장 앞에 `default` 라고 표기해야 함.
- 이렇게 인터페이스에 구현한 printFood() 디폴트 메서드를 Tiger, Lion 등의 실제 클래스에서의 구현없이도 사용 가능
- 디폴트 메서드는 오버라이딩이 가능
  - 즉, printFood 메서드를 실제 클래스에서 다르게 구현하여 사용할 수 있음



## 스태틱 메서드

- 인터페이스에서 스태틱 메서드를 구현하면 `인터페이스명.스태틱메서드명` 과 같이 사용하여 일반 클래스의 스태틱 메서드를 사용하는 것과 동일하게 사용할 수 있음

```java
interface Predator {
    String getFood();

    default void printFood() {
        System.out.printf("my food is %s\\n", getFood());
    }

    int LEG_COUNT = 4;  // 인터페이스 상수

    static int speed() {
        return LEG_COUNT * 30;
    }
}
```

- 위처럼 speed() 스태틱 메서드를 추가하면 다음과 같이 사용 가능
  - `Predator.speed();`



### 인터페이스 상수

- 위 코드에서 사용한 `int LEG_COUNT = 4;` 문장은 인터페이스에 정의한 상수
- 이처럼 `public static final` 을 생략해도 자동으로 `public static final` 이 적용된다.
  - 다른 형태의 상수 정의는 불가능
